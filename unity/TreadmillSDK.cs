// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace Treadmill
{
    internal static unsafe partial class TreadmillSDK
    {
#if UNITY_IOS && !UNITY_EDITOR
        const string __DllName = "__Internal";
#else
        const string __DllName = "treadmill_sdk";
#endif
        



        /// <summary>
        ///  初始化日志记录功能
        ///
        ///  # 参数
        ///  - `level`: 日志级别
        /// </summary>
        [DllImport(__DllName, EntryPoint = "initialize_logging", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void initialize_logging(LogLevel level);

        /// <summary>
        ///  AES-GCM 加密函数
        ///
        ///  # 参数
        ///  - `plaintext`: 指向待加密数据的指针
        ///  - `len`: 数据长度（字节）
        ///  - `user_id`: 用户 ID（C 字符串）
        ///  - `sn_code`: 设备序列号（C 字符串）
        ///  - `out_len`: 加密后的数据长度（字节）
        ///
        ///  # 返回值
        ///  - 成功: 返回加密后的密文
        ///  - 失败: 返回 `NULL`
        ///
        ///  # 注意
        ///  - 传入的指针必须有效，否则返回 `NULL`
        ///  - C 代码端需要在使用完返回的字符串后调用 `free_encrypted_or_decrypted` 释放内存
        ///
        ///  # Example
        ///  ```c
        ///  const char* plaintext = "Hello, Device!";
        ///  const char* user_id = "550e8400-e29b-41d4-a716-446655440000";
        ///  const char* sn_code = "SN123456";
        ///  size_t out_len = 0;
        ///  uint8_t* encrypted = tml_encrypt((const uint8_t*)plaintext, strlen(plaintext), user_id, sn_code, &amp;out_len);
        ///  if (encrypted != NULL) {
        ///      free_encrypted_or_decrypted(encrypted);
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "tml_encrypt", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* tml_encrypt(byte* plaintext, nuint len, byte* user_id, byte* sn_code, nuint* out_len);

        /// <summary>
        ///  AES-GCM 解密函数
        ///
        ///  # 参数
        ///  - `ciphertext`: 指向待解密数据的指针
        ///  - `len`: 数据长度（字节）
        ///  - `user_id`: 用户 ID（C 字符串）
        ///  - `sn_code`: 设备序列号（C 字符串）
        ///  - `out_len`: 解密后的数据长度（字节）
        ///
        ///  # 返回值
        ///  - 成功: 返回解密后的`uint8_t` 指针
        ///  - 失败: 返回 `NULL`
        ///
        ///  # 注意
        ///  - 传入的指针必须有效，否则返回 `NULL`
        ///  - C 代码端需要在使用完返回的字符串后调用 `free_encrypted_or_decrypted` 释放内存
        ///
        ///  # Example
        ///  ```c
        ///  const char* ciphertext = "encrypted data";
        ///  const char* user_id = "550e8400-e29b-41d4-a716-446655440000";
        ///  const char* sn_code = "SN123456";
        ///  size_t out_len = 0;
        ///  uint8_t* decrypted = tml_decrypt((const uint8_t*)ciphertext, strlen(ciphertext), user_id, sn_code, &amp;out_len);
        ///  if (decrypted != null) {
        ///      free_encrypted_or_decrypted(decrypted);
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "tml_decrypt", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* tml_decrypt(byte* ciphertext, nuint len, byte* user_id, byte* sn_code, nuint* out_len);

        /// <summary>
        ///  释放由 `encrypt` 或 `decrypt` 生成的数据
        ///
        ///  # 参数
        ///  - `ptr`: 由 `encrypt` 或 `decrypt` 返回的 `uint8_t` 指针
        ///  - `len`: 数据长度，与 `out_len` 返回的值一致
        ///
        ///  # 注意
        ///  - 仅应释放由 `encrypt` 或 `decrypt` 分配的内存
        ///  - 传入 `NULL` 安全无副作用
        /// </summary>
        [DllImport(__DllName, EntryPoint = "free_encrypted_or_decrypted", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void free_encrypted_or_decrypted(byte* ptr, nuint len);


    }



}
